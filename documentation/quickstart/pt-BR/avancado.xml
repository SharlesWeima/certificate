<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>

<chapter id="avancado">
	<title>Usando um carimbo de tempo</title>
	<section>
		<title>Como funciona</title>
		<para>
			Para usar a política AD_RT do ICP-Brasil precisamos requisitar uma referência temporal digital a uma ACT que possua um servidor devidamente homologado.
			O componente <literal>demoiselle-certificate-timestamp</literal> possui toda a implementação necessária para acessar o servidor de carimbo de tempo do SERPRO.
			Para obter uma referência temporal é necessário assinar uma requisição usando certificado que esteja autorizado a acessar esse servidor e assim gerar uma
			assinatura de documento com referência temporal.
		</para>
	    <para>
            <figure>
                <title>
                    Arquitetura padrão
                </title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/timestamp01.png" format="PNG" align="center" scalefit="1" width="75%"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>		
	
		<para>
			Para aplicações que disponibilizam assinatura com referência temporal para diversos usuários essa implementação
			padrão pode não ser a ideal, pois será necessário autorizar cada usuário para obter um carimbo de tempo.
			Pensando nisso está disponível no componente a opção de criarmos nossa própria classe para obter o carimbo de tempo. 
		</para>
		<para>
			Em nossa aplicação vamos criar uma implementação de gerador de timestamp que ao invés de pedir ao servidor um carimbo
			usando o certificado que assina o documento, pediremos a um servidor que tenha acesso a um certificado de máquina devidamente autorizado.
			A assinatura do documento será feita pelo certificado do usuário que terá um carimbo de tempo para aquele conteúdo gerado com um certificado de aplicação.
			Nossa implementação irá enviar o conteúdo lido pela applet para um Servlet que irá carregar o certificado da aplicação e solicitar o carimbo de tempo.
			Em nosso exemplo usamos Servlet, mas você também pode usar um serviço REST ou um WebService, lembrando apenas que é importante esse serviço exigir
			autenticação para que possa ser acessado.
		</para>
	    <para>
            <figure>
                <title>
                    Arquitetura com Servlet
                </title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/timestamp02.png" format="PNG" align="center" scalefit="1" width="75%"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>		
	</section>
	
	<section>
		<title>Criando uma Servlet para gerar o TimeStamp</title>
		<para>
			Em nosso projeto web, vamos adicionar ao pom.xml a dependência do componente <literal>demoiselle-certificate-timestamp</literal>. 
			Vamos utilizar sua API para	gerar um carimbo de tempo.
		</para>
        <programlisting role="XML"><![CDATA[<dependency>
	<groupId>br.gov.frameworkdemoiselle.component</groupId>
	<artifactId>demoiselle-certificate-timestamp</artifactId>
	<version>2.0.0</version>
</dependency>]]></programlisting>
		<para>
			Em nosso servlet vamos executar tres atividades dinstintas:
			1 - Leitura do certificado A1 (link para documentação de referencia)
			2 - Leitura do conteúdo enviado pela apllet
			3 - Requisição ao servidor de carimbo de tempo usando o certificado A1
		</para>
<programlisting role="Java"><![CDATA[
@WebServlet("/carimbo")
//@ServletSecurity(value = @HttpConstraint(rolesAllowed = "admin"))
public class TimestampGeneratorServlet extends HttpServlet {

	private static final Logger logger = LoggerFactory
			.getLogger(TimestampGeneratorServlet.class);

	
	private static final long serialVersionUID = 1L;

	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		System.out.println("DoGET");
		this.doPost(request, response);
	}

	@Override
	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		
		PrivateKey privateKey = null;
		Certificate[] certificates = null;
		byte[] content = null;

		String configName = "/home/01534562567/drivers.config";
		String password = "qwaszx12!";

		Provider p = new sun.security.pkcs11.SunPKCS11(configName);
		Security.addProvider(p);

		KeyStore ks = null;
		try {

			ks = KeyStore.getInstance("PKCS11", "SunPKCS11-Provedor");

			ks.load(null, password.toCharArray());

			String alias = "";

			KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(
					password.toCharArray());

			Enumeration<String> e = ks.aliases();
			while (e.hasMoreElements()) {
				alias = e.nextElement();
				certificates = ks.getCertificateChain(alias);
			}

			KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry) ks
					.getEntry(alias, protParam);
			privateKey = pkEntry.getPrivateKey();

			//Lendo o Conteúdo enviado
			String contentType = request.getContentType();
			if ("application/octet-stream".equals(contentType)|| contentType.isEmpty() || "application/x-www-form-urlencoded".equals(contentType)) {
				content = IOUtils.toByteArray(request.getInputStream());
			} else{
				response.setContentType("text/plain");
				response.setStatus(415);
			}
			
			//requisitando um carimbo de tempo
			TimeStampOperator timeStampOperator = new TimeStampOperator();
			byte[] reqTimestamp = timeStampOperator.createRequest(privateKey,
					certificates, content);

			content = timeStampOperator.invoke(reqTimestamp);

			response.setContentType("application/octet-stream");
			response.getOutputStream().write(content);
			response.getOutputStream().flush();
			response.getOutputStream().close();

		} catch (CertificateCoreException e) {
			response.setContentType("text/plain");
			response.setStatus(500);
			response.getOutputStream().write(e.getMessage().getBytes());
			response.getOutputStream().flush();
			response.getOutputStream().close();
		} catch (Exception e) {
			response.setContentType("text/plain");
			response.setStatus(500);
			response.getOutputStream().write("Erro ao fazer load do certificado habilitado para requisitar carimbo de tempo".getBytes());
			response.getOutputStream().flush();
			response.getOutputStream().close();
		} finally {
			// TODO

		}
	}>]]></programlisting>		
	</section>	
	<section>
		<title>Criando uma implementação de TimeStampGenerator</title>
		<para>
			Como já explicamos a implementação padrão do componente requisita usando a pk do usuario. Podemos pedir para a aplicação fazer
			essa solicitação criando uma implementação própria que se conecta 
		</para>
		
	</section>

	<section>
		<title>Adicionando segurança</title>
	</section>
	
	<section>
		<title>Teste de destaque</title>
		<programlistingco>
			<areaspec>
				<area id="inject-context" coords="5"/>
				<areaset id="add-msg-context" coords="">
					<area id="" coords="2"/>
					<area id="" coords="5"/>
					<area id="" coords="7"/>
				</areaset>
			</areaspec>
			<programlisting role="JAVA">
<![CDATA[
Linha 1
linha 2
linha 3
linha 4
linha 5
linha 6 
linha 7 
linha 8

]]></programlisting>

<calloutlist>
				<callout arearefs="inject-context">
					<para>
						X
					</para>
				</callout>
				<callout arearefs="add-msg-context">
					<para>
						Y
					</para>
				</callout>
			</calloutlist>
		</programlistingco>
		
	</section>
</chapter>
